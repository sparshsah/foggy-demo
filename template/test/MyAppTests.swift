// author: sparshsah

import XCTest
/*
 In practice, you'd uncomment the below (replacing `MyApp` with your app name).
 `@testable` "temporarily" exposes internal attributes as public for testing purposes.
 */
// @testable import MyApp  // target source code

// pretend this code defining `MyError` and `myFuncThatThrows` actually lives in `MyApp`
enum MyError: Error {
    case myExpectedError
    case myUnexpectedError
}

func myFuncThatThrows(myErrToThrow: Int = -1) throws {
    if myErrToThrow < 0 {
        return
    } else if myErrToThrow == 0 {
        throw MyError.myExpectedError
    } else {
        throw MyError.myUnexpectedError
    }
}

/*
 An Xcode unit-test bundle (AKA target) can contain multiple
 unit-test sourcefiles like `MyAppTests.swift`, which can contain multiple
 unit-test case classes like `SkeletonTests`, which can contain multiple
 unit-test funcs like `testSkeleton()`.
 */

// Auto-generated by Xcode.
class SkeletonTests: XCTestCase {

    // same as `setUp` except can throw
    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }

    // same as `tearDown` except can throw
    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    func testSkeleton() throws {
        // This is an example of a functional test case.
        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    func testPerformanceSkeleton() throws {
        // This is an example of a performance test case.
        self.measure {
            // Put the code you want to measure the time of here.
        }
    }

}

// demonstrate that each unit-test func is run from a brand-new, isolated XCTestCase instance
class SetUpTests: XCTestCase {

    var t = 0

    override func setUpWithError() throws {
        t += 1  // implicitly `self.t += 1`
    }

    override func tearDownWithError() throws {
        t += 1
    }

    func test0() throws {
        // before this, `setUpWithError()` was run, so this will pass
        XCTAssertEqual(t, 1)
        // after this, `tearDownWithError()` will be run
    }

    func test1() throws {
        /*
         Now comes the trick: Even though right before this line,
         `setUpWithError()` was run "again", `self.t` will still be `1`!

         Naive programmers like me might expect the following:
         >>> SetUpTests()  // instantiate XCTestCase, t == 0
         >>> setUpWithError()  // t == 1
         >>> test0()  // t == 1
         >>> tearDownWithError()  // t == 2
         >>> setUpWithError()  // t == 3
         >>> test1()  // t == 3
         >>> tearDownWithError()  // t == 4

         But in reality, it's:
         >>> SetUpTests()  // instantiate XCTestCase, t == 0
         >>> setUpWithError()  // t == 1
         >>> test0()  // t == 1
         >>> tearDownWithError()  // t == 2
         >>> SetUpTests()  // instantiate XCTestCase, t == 0 again!!!
         >>> setUpWithError()  // t == 1
         >>> test1()  // t == 1
         >>> tearDownWithError()  // t == 2
         */
        XCTAssertEqual(t, 1)
    }
}

class FloatEqualTests: XCTestCase {

    let x: Float = 1.0
    let y: Float = x
    let z: Float = x + 0.01

    func testBinaryReprEqual() throws {
        XCTAssertEqual(x, y)
    }

    func testTightNumericalEqual() throws {
        XCTAssertEqual(x, y, accuracy: 1e-4)
    }

    func testLooseNumericalEqual() throws {
        XCTAssertEqual(x, z, accuracy: 0.1)
    }

    func testNotBinaryReprEqual() throws {
        XCTAssertNotEqual(x, z)
    }

    func testNotNumericalEqual() throws {
        XCTAssertNotEqual(x, z, accuracy: 1e-4)
    }

}

class ThrowTests: XCTestCase {

    func testNoThrow() throws {
        XCTAssertNoThrow(try myFuncThatThrows())
    }

    func testThrows() throws {
        XCTAssertThrowsError(try myFuncThatThrows(myErrToThrow: 0))
    }

    func testThrowsSomethingExpected() throws {
        XCTAssertThrowsError(try myFuncThatThrows(myErrToThrow: 0)) { error in
            XCTAssertEqual(error as! MyError, MyError.myExpectedError)
        }
    }

    func testThrowsSomethingUnexpected() throws {
        XCTAssertThrowsError(try myFuncThatThrows(myErrToThrow: 1)) { error in
            XCTAssertNotEqual(error as! MyError, MyError.myExpectedError)
        }
    }
}
